// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../celestia/lib/DataRootTuple.sol";
import "../celestia/lib/tree/binary/BinaryMerkleTree.sol";

import {IBlobstreamX} from "../celestia/IBlobstreamX.sol";

// make a "MockOSP" that uses the address generated by the Mockstream deployment

contract Mockstream is IBlobstreamX {
    /// @notice The block is the first one in the next data commitment.
    uint64 public latestBlock;

    /// @notice Nonce for proof events. Must be incremented sequentially.
    uint256 public state_proofNonce;

    /// @notice Mapping of data commitment nonces to data commitments.
    mapping(uint256 => bytes32) public state_dataCommitments;

    /// @notice Indicator of if the contract is frozen.
    bool public frozen;

    /// @dev Initializes the contract.
    function initialize(uint64 _latestBlock) external {
        frozen = false;
        latestBlock = _latestBlock;
        state_proofNonce = 1;
    }

    /// @notice Only the guardian can set the contract to a frozen state.
    function updateFreeze(bool _freeze) external {
        frozen = _freeze;
    }

    /// @notice Only the guardian can update the genesis state of the light client.
    function updateGenesisState(uint64 _height) external {
        latestBlock = _height;
    }

    function submitDataCommitment(
        bytes32 _dataCommitment,
        uint64 _beginBlock,
        uint64 _endBlock
    ) external {
        if (latestBlock > _beginBlock || _beginBlock > _endBlock) {
            revert("INVALID RANGE");
        }
        state_dataCommitments[state_proofNonce] = _dataCommitment;

        emit DataCommitmentStored(state_proofNonce, _beginBlock, _endBlock, _dataCommitment);

        state_proofNonce++;
        latestBlock = _endBlock;
    }

    /// @dev Verify the attestation for the given proof nonce, tuple, and proof. This is taken from
    /// the existing Blobstream contract and is used to verify the data hash for a specific block
    /// against a posted data commitment.
    function verifyAttestation(
        uint256 _proofNonce,
        DataRootTuple memory _tuple,
        BinaryMerkleProof memory _proof
    ) external view returns (bool) {
        if (frozen) {
            revert ContractFrozen();
        }

        // Note: state_proofNonce slightly differs from Blobstream.sol because it is incremented
        //   after each commit.
        if (_proofNonce == 0 || _proofNonce >= state_proofNonce) {
            return false;
        }

        // Load the tuple root at the given index from storage.
        bytes32 root = state_dataCommitments[_proofNonce];

        // Verify the proof.
        (bool isProofValid, ) = BinaryMerkleTree.verify(root, _proof, abi.encode(_tuple));

        return isProofValid;
    }
}
